<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
  </head>
  <style>
    .cursor-pointer{
      cursor: pointer;
    }
  </style>
  <body>
    <div style="height: 50px;" class="container-fluid px-0 px-3">
     <div class="row">
      <div class="col-3 px-3">
        <div id="TG" onclick="setClickFunction(this.id)" class="py-2 rounded-pill d-flex justify-content-center align-items-center border cursor-pointer">
          Toggle Goal
        </div>
      </div>
      <div class="col-3 px-3">
        <div id="TB" onclick="setClickFunction(this.id)" class="py-2 rounded-pill d-flex justify-content-center align-items-center border cursor-pointer">
          Toggle Barrier
        </div>
      </div>
      <div class="col-3 px-3">
        <div id="AW" onclick="setClickFunction(this.id)" class="py-2 rounded-pill d-flex justify-content-center align-items-center border cursor-pointer">
          Add Worm
        </div>
      </div>
      <div class="col-3 px-3">
        <div onclick="kill()" class="py-2 rounded-pill d-flex justify-content-center align-items-center border cursor-pointer">
          Kill
        </div>
      </div>
     </div>
    </div>
    <div class="container-fluid">
        <div id="container" class="row">

        </div>
    </div>
  </body>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
  <script>
    const colors = ["red", "yellow", "pink", "blue", "green", "indigo", "orange", "lightblue", "black"];

    const NODE_TYPE_GOAL = "G";
    const NODE_TYPE_BARRIER = "B";
    const NODE_TYPE_STEP = "S";

    const FUNCTION_TOGGLE_GOAL = "TG";
    const FUNCTION_TOGGLE_BARRIER = "TB";
    const FUNCTION_ADD_WORM = "AW";

    let doOnClick = FUNCTION_ADD_WORM;
    let goalNode = null;

    const height = document.documentElement.clientHeight - 50;
    const width = document.documentElement.clientWidth;
    
    let unitHeight = null;
    let unitWidth = null;

    let cellHeight = null;
    let cellWidth = null;

    let wormHeight = null;
    let wormWidth = null;

    let maxXCells = null;

    const alreadyVisitedNodes = {};

    const parent = document.getElementById("container");

    function setClickFunction(functionType) {
      const buttonIds = [FUNCTION_TOGGLE_GOAL, FUNCTION_TOGGLE_BARRIER, FUNCTION_ADD_WORM];
      buttonIds.forEach((id)=>{
        const curButton = document.getElementById(id);
        if(id !== functionType) {
          curButton.classList.remove("bg-primary");
        }else{
          curButton.classList.add("bg-primary");
        }
      })
      doOnClick = functionType;
    }

    function isNodeABarrier(nodeId){
      return parent.children[nodeId].dataset.type === NODE_TYPE_BARRIER;
    }

    function getRandomNumber(max) {
      return Math.floor(Math.random()*max)
    }

    function getRandomColor() {
      return colors[getRandomNumber(colors.length)];
    }    

    function getCoOrdinates(nodeId) {
      const node = parent.children[nodeId].getBoundingClientRect();
      const x = Math.floor(node.left + (node.width/2));
      const y = Math.floor(node.top + (node.height/2));
      return [x, y];
    }

    function getManhattanDisatnce(a, b) {
      return (Math.abs(b[0] - a[0]) + Math.abs(b[1] - a[1]));
    }

    let getNeighbors = null;
      
    const directionByIndex = {0: "U", 1: "R", 2: "D", 3: "L"};
    const indexByDirection = Object.entries(directionByIndex).reduce((acc, cur)=> ({...acc, [cur[1]]: Number(cur[0])}), {});

    function selectNeighborNearestToGoal (currentNode, previousNode, neighbors) {
      let positions = neighbors.filter((neighborId)=> neighborId !== null && parent.children[neighborId].dataset.type !== NODE_TYPE_BARRIER);
      let selectedNode = null;
      if(positions.length === 0){
        return null;
      }
      if(positions.length === 0){
        return null;
      }
      const goalCoordinates = getCoOrdinates(goalNode);
      let positionAndDistance = positions.map((positionId)=> {
        const positionCoordinates = getCoOrdinates(positionId);
        return [positionId, getManhattanDisatnce(goalCoordinates, positionCoordinates)]
      });
      positionAndDistance = positionAndDistance.sort((a, b)=> a[1] - b[1]);
      positionAndDistance = positionAndDistance.sort((a, b)=> {
        if(alreadyVisitedNodes[a[0]] === undefined && alreadyVisitedNodes[b[0]] === undefined){
          return 0;
        }else if(alreadyVisitedNodes[a[0]] === undefined){
          return -1;
        }else if(alreadyVisitedNodes[b[0]] === undefined){
          return 1;
        } else {
          return alreadyVisitedNodes[a[0]] - alreadyVisitedNodes[b[0]];
        }
      });
      return positionAndDistance[0][0];
    }

    function handleClick(nodeId) {
      if(doOnClick === FUNCTION_TOGGLE_GOAL){
        if(parent.children[nodeId].dataset.type === NODE_TYPE_GOAL){
          parent.children[nodeId].style.background = "white";
          parent.children[nodeId].dataset.type = NODE_TYPE_STEP;
          goalNode = null;
        }else{
          parent.children[nodeId].style.background = "green";
          parent.children[nodeId].dataset.type = NODE_TYPE_GOAL;
          if(goalNode){
            parent.children[goalNode].style.background = "white";
          }
          goalNode = nodeId;
        }
        return;
      }else if(doOnClick === FUNCTION_TOGGLE_BARRIER){
        if(parent.children[nodeId].dataset.type === NODE_TYPE_BARRIER){
          parent.children[nodeId].style.background = "white";
          parent.children[nodeId].dataset.type = NODE_TYPE_STEP;
        }else{
          parent.children[nodeId].style.background = "grey";
          parent.children[nodeId].dataset.type = NODE_TYPE_BARRIER;
        }
        return;
      }else{
        move(nodeId);
      }
    }

    let killed = false;
    function kill() {
      killed = true;
      alreadyVisitedNodes = {};
      setTimeout(()=>{
        killed = false;
      }, 3000)
    }

    function move(nodeId, previousNode = null, color=getRandomColor()) {
      if(killed){
        return;
      }
      if(goalNode === null){
        alert("No goal, no purpose, the hell you want me to do?");
        return;
      }

      const neighbors = getNeighbors(Number(nodeId));
      const selectedPosition = selectNeighborNearestToGoal(nodeId, previousNode, neighbors);
      if(!selectedPosition){
        alert("No way found");
        return;
      }

      const direction = directionByIndex[neighbors.indexOf(selectedPosition)];
      const angleByDirection = {"U": 90, "R": 180, "D": 270, "L": 0};

      const img = document.createElement("img");
      img.src = "worm.png";
      img.style.width = `${wormWidth}px`;
      img.style.height = `${wormHeight}px`;
      img.style.transform = `rotate(${angleByDirection[direction]}deg)`;
      parent.children[nodeId].appendChild(img);
      if(alreadyVisitedNodes[nodeId]){
        alreadyVisitedNodes[nodeId] += 1
      }else{
        alreadyVisitedNodes[nodeId] = 1;
      }

      setTimeout(()=>{
        const child = parent.children[nodeId];
        if(child.dataset.type !== NODE_TYPE_GOAL){
          child.innerHTML = "";
          parent.children[nodeId].style.background = color;
          move(selectedPosition, nodeId, color);
        }
      }, 250);
    }

    function populateCells(numberOfCells, addBarriers = false, barrierPercentage = 20) {
      const sqrt = Math.sqrt(numberOfCells);

      unitHeight = Math.floor(height/sqrt);
      unitWidth = Math.floor(width/sqrt);

      cellHeight = `${unitHeight}px`;
      cellWidth = `${unitWidth}px`;

      wormHeight = Math.floor(unitHeight - (unitHeight * 0.05))
      wormWidth = Math.floor(unitWidth - (unitWidth * 0.1))

      maxXCells = Math.floor(width/unitWidth);

      getNeighbors = function (nodeId) {
        const xBound = [];

        xBound.push(Math.floor(nodeId/maxXCells) * maxXCells);
        xBound.push(((Math.ceil((nodeId/maxXCells)+0.000001)) * maxXCells) - 1);

        const top = (nodeId - maxXCells) >= 0 ? (nodeId - maxXCells) : null;
        const right = (nodeId + 1) <= xBound[1] && (nodeId+1) <= (numberOfCells-1) ? (nodeId + 1) : null;
        const bottom = (nodeId + maxXCells) <= (numberOfCells-1) ? (nodeId + maxXCells) : null;
        const left = (nodeId - 1) >= xBound[0] ? (nodeId - 1) : null;
        return [top, right, bottom, left];
      }

      for (let i = 0; i < numberOfCells; i++){
        let element = `<div data-id=${i} data-type=${NODE_TYPE_STEP} style="height: ${cellHeight}; width: ${cellWidth}; transition: background 0.3s linear; padding: 0px; background: white" onclick="handleClick(this.dataset.id)">${i}</div>`;
        if(addBarriers){
          const isABarrier = Math.random() * 100;
          element = `<div data-id=${i} data-type=${isABarrier > barrierPercentage ? NODE_TYPE_STEP : NODE_TYPE_BARRIER} style="height: ${cellHeight}; width: ${cellWidth}; transition: background 0.3s linear; padding: 0px; background: ${isABarrier > barrierPercentage ? 'white' : 'grey'}" onclick="handleClick(this.dataset.id)">${i}</div>`;
        }
        parent.innerHTML += element;
      }
    }
    populateCells(800, true, 20);
  </script>
</html>